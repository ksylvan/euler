# Prime Digit Replacement

# By replacing the 1st digit of the 2-digit number [_][3], it turns out that six of the nine
# possible values: 13, 23, 43, 53, 73, and 83, are all prime.

# By replacing the 3rd and 4th digits of [5][6][_][_][3] with the same digit, this 5-digit number
# is the first example having seven primes among the ten generated numbers, yielding the
# family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being
# the first member of this family, is the smallest prime with this property.

# Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits)
# with the same digit, is part of an eight prime value family.

from typing import List

from primes import is_prime, next_prime
from testing import report_timing, run_doctest, timer


@timer
def find_smallest_prime(m: int, limit: int) -> List[int]:
    """
    This function finds the smallest prime number which can be generated by replacing part of
    the number (not necessarily adjacent digits) with the same digit, and this generates an
    m-prime value family.
    
    >>> find_smallest_prime(1, 1000000)
    >>> find_smallest_prime(3, 1000)
    [113, 223, 443, 773, 883]
    >>> find_smallest_prime(6, 10000)
    [1009, 1229, 1559, 1669, 1889, 1999]
    >>> find_smallest_prime(7, 1000000)
    [56003, 56113, 56333, 56443, 56663, 56773, 56993]
    """
    if m < 2:
        return None
    my_primes = next_prime(from_start=True, limit=limit)
    for p in my_primes:
        str_p = str(p)
        digits = set(str_p)
        for digit in digits:
            if str_p.count(digit) < 2:
                continue
            families = {digit: [] for digit in digits}
            for i in range(10):
                new_number = str_p.replace(digit, str(i))
                if new_number[0] == '0':
                    continue
                if is_prime(int(new_number)):
                    families[digit].append(int(new_number))
            for count in families:
                if len(families[count]) >= m:
                    return families[count]
    return None  # if no prime with an m-membered family is found

if __name__ == '__main__':
    run_doctest()
    family = find_smallest_prime(8, 1000000)
    print(f"@ Euler problem 51 answer: {family[0]}")
    print(f"@ That represents this prime family of numbers: {family}")
    report_timing()